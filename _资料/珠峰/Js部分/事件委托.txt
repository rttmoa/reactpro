事件具备传播机制：
  当我们触发了ELE元素的某个行为
  + 第一步：捕获阶段「CAPTURING_PHASE」，从最外层window开始，找到ELE这个元素「为冒泡传播机制规划传播路径」
    在此阶段，会把所有定义在捕获阶段的事件绑定触发
    xxx.addEventListener('click',func,true); //最后参数不设置，默认是false
    xxx.addEventListener('click',func,{ capture:true });
    在ev事件对象中，有一个path的属性，记录了它规划的路径
  + 第二步：目标阶段「AT_TARGET」，把事件源的相关行为触发，如果做过事件绑定，则把绑定的方法也执行！！
  + 第三步：冒泡阶段「BUBBLING_PHASE」，按照规划的传播路径（从内到外），把祖先元素的相关事件行为依次触发（如果绑定了方法，方法也会执行）！！
  -----
  部分事件是不具备传播机制的，例如：mouseenter/mouseleave、load、resize、scroll...
  而且我们还可以自己阻止“冒泡传播”：ev.stopPropagation/stopImmediatePropagation
扩展：addEventListener的语法！！
扩展：ev.stopPropagation/stopImmediatePropagation的区别？


事件委托：一定要依赖于事件的“冒泡传播”机制
  例如：一个容器中，有很多元素都要在点击的时候干点啥事？
    @1 逐一获取相关的元素，然后分别做事件绑定「同类型/或者要做相同事情的，还可以循环事件绑定」
      + 这样的方式，代码要写很多，操作起来麻烦
      + 循环事件绑定，如果需要保留索引，则会产生一些不被释放的闭包，消耗性能
      + 我们要获取很多元素，则会开辟大量的堆内存
      + ...
    @2 如果我们使用事件委托，只需要给容器的点击事件绑定方法即可「因为：点击容器中的任意元素，根据冒泡传播机制，都会触发容器的点击事件」
      + 在绑定的方法中，获取事件源 ev.target
      + 根据事件源判断，不同的事件源，我们做不同的处理
      container.onclick=function(ev){
        let target=ev.target;
        if(target是左按钮){
            ....
            return;
        }
        ......
      };
    ====> 基于事件委托，可以大幅度提高事件绑定的性能「大约40%~60%+」

  例如：一个容器，刚开始是没有内容的，当我们从服务器获取数据后，内容是动态绑定出来的，我们需要给动态创建的内容，进行事件绑定！
    @1 需要等待元素动态创建完毕后，再去获取相关元素，逐一做绑定！！
      + 需要非常严谨的逻辑「获取数据是异步的，我们需要在异步结束后，去处理事件绑定」
    @2 如果用事件委托，则不管你是写死的，还是动态创建的，跟老子没关系，我只给容器进行事件绑定即可；「之所以不需要在乎先后逻辑，原因：我不需要获取元素，拿到容器即可，在容器绑定的方法中，根据事件源做处理；用户只有点击，根据传播机制，才会触发我们绑定的方法，而用户都可以点击了，说明肯定动态创建完毕了！！」
    ====> 基于事件委托，可以给动态创建的元素做事件绑定，而不用很严格的关注逻辑顺序
  
  例如：我们需要实现，点击某个按钮控制详情的展示或者隐藏；点击详情啥都不干；但是点击剩余所有其他东西，都是控制详情消失！！
    @1 不用事件委托，我们需要获取页面中所有元素，所有元素都要做事件绑定....脑子有毛病才会这样干！！
    @2 肯定需要基于事件委托处理
    document.onclick=function(ev){
        let target=ev.target;
        if(target是按钮){
            // 控制详情的显示隐藏
            return;
        }
        //剩下情况都是让详情隐藏
    }
    详情盒子.onclick=function(ev){
        ev.stopPropagation();
    };
    ====> 某些需要求必须基于事件委托处理！！

总结：以后真实项目中，能用(或有必要用)事件委托处理的，坚决使用事件委托！！！