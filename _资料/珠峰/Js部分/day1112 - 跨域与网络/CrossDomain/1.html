<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		浏览器为了安全，提供了一个安全策略：协议，域名，端口 必须相同，这个策略，叫同源策略
		
		要求客户端 和 服务器 协议，域名，端口，必须一致，才能访问数据，其中一项不一致也不行
		
		https://www.baidu.com
		协议: https
		域名: www.baidu.com
		端口号:443(默认)
		
		客户端：http://127.0.0.1:8848
		服务器：https://www.jianshu.com/asimov/subscriptions/recommended_collections
		
		跨域：让协议，域名，端口号不同，也能获取数据（前提条件,服务器不做限制）
		1. cros(服务器)
		   设置白名单
		   let safeList = ["http://127.0.0.1:8848","http://127.0.0.1:5500","http://127.0.0.1:5501"];
		   
		   let origin = req.headers.origin || req.headers.referer || "";
		   origin = origin.replace(/\/$/g, '');
		   origin = !safeList.includes(origin) ? '' : origin;
		   res.header("Access-Control-Allow-Origin", origin);
		   
		   直接设置为 "*",允许所有源访问
		   res.header("Access-Control-Allow-Origin", "*");
		   客户端一定要将 withCredentials: false (不予许携带跨域资源凭证)
		   
		2. proxy 代理 (客户端) 
		     nodejs-------（学习案例，CrossDomain---server-proxy.js)
			 webpack(vue)  (学习案例 proxydemo---vue.config.js--固定语法，以后具体学)
			 nginx
		
		3. jsonp (客户端)----只能获取get请求类的跨域，post系列不行
		
		    img/link/script, 不会受到域的限制，直接获取数据,只是通过get方式获取数据  
		    不会受到域的限制，直接获取数据,并且还能在js中使用数据，只能选择script

		4. postMessage + iframe （了解）
           postMessage、window.name、document.domin、location.hash、...这些方案结合 iframe 也可以实现跨域处理
		
		
		<script src="axios.min.js"></script>
		<script>
			// 客户端: http://127.0.0.1:8848
			// 现在客户端，依旧是 8848,如何变成1001
			// 1. 将1.html 放到 CrossDomain（服务器文件夹） 里面，重新启动服务
			// 2. 不能直接打开，要用服务器的方式打开 http://127.0.0.1:1001/1.html
			
			// 代理服务器:http://127.0.0.1:1001/aaa
			// 简书服务器:https://www.jianshu.com/asimov/subscriptions/recommended_collections
			//失败
			axios.get("http://127.0.0.1:1001/aaa")
		    .then(res=>{
				console.log(res)
			}).catch(err=>{
				console.log(err);
			})
		</script>
	</body>
</html>
