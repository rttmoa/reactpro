<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		从输入URL地址到看到页面，中间都经历了啥？
		
		第一步：URL解析
		目的：解析URL的每一部分，找到关键内容，针对性的发送请求
		
		一个完整的URL包含哪些部分
		1.传输协议(作用是实现客户端和服务器的数据传输)
		   http:超文本传输协议（除了文本，还可以传输图片，视频...等资源）
		   https:加密版的HTTP, HTTP+SSL,所以更安全（一般用于支付类)
		   ftp:专门上传文件，把开发的文件上传到服务器进行部署
		2.域名
		  给外网IP起一个好记忆的名称
		  198.5.45.7---》www.yk.com
		3.端口号
		  区分服务器上，不同的服务
		  取值范围 0--65535
		  端口号是可以省略的，有默认值
		  http----80
		  https---443
		  ftp-----21
		4.请求资源的文件路径
		5.问号传参
		  客户端向服务起发送请求时，可以携带的参数
		  get类ajax请求，就是通过问号传参，发送参数的
		6.HASH值
		  锚点定位(css)  HASH路由(vue)
		  
		URL信息编码问题：如果URL含有中文，防止中文出现乱码，需要对中文进行编码，获取完信息后解码
		encodeURI/decodeURI 编码和解码不会特变严谨（不会编码空格）
		encodeURIComponent/decodeURIComponent  编码和解码更加严谨（包含空格之类的）
		escape/unscape
		
		第二步：缓存检查
		   把内容缓存本地，具体方案
		   数据缓存：基于 cookie/localStorage...等方案处理即可
		   资源缓存：浏览器会自己存储，存储的位置 “虚拟内存存储 Memory Cache” 和 ”物理内存存储 Disk Cache“
		   
		   +页面普通刷新（F5）:先去虚拟内存存储 Memory Cache，找不到 物理内存存储 Disk Cache
		   +关闭页面重新打开：直接去 物理内存存储 Disk Cache
		   +页面强制刷新（CTRL+F5)：即不去虚拟内存存储 Memory Cache，也不去物理内存存储 Disk Cache，去服务器直接重新获取数据
		
		静态资源文件缓存的处理方案：强缓存 和 协商缓存（服务器）
	       浏览器会自己识别和配合服务器完成缓存的建立和查找，不需要前端写任何代码，不需要设置缓存，
		   缓存服务器返回信息的时候，设置的规则[服务器设置，浏览器配合]
		   1.强缓存（有缓存，不会向服务器发送请求）
		   第一访问，本地没有任何缓存，直接去服务器获取数据，如果服务器要设置“强缓存”，则
		   会在响应头返回两个字段 （Expires Cache-control)
		   
		   Cache-Control: max-age=315360000（秒）  指定多长时间过期
		   Expires: Thu, 09 Sep 2032 12:20:39 GMT 指定那天过期
		   
		   HTTP/1.0用Expires，HTTP/1.1用Cache-Control（常用），如果都存在则1.1版本的为主
		   
		   Cache-Control: private 不设置强缓存
		   
		   浏览器接收到资源信息后，渲染页面的同时，查看一下返回缓存的字段，
		   如果没有Expires Cache-control或者是Cache-Control: private，则不会在缓存里存储
		   如果有设定了过期时间（不是立刻失效），就把缓存信息（有效期和相关标识）存储，并且也会将数据（图片）缓存到本地
		   
		   第二次访问以及多次，首先看本地缓存
		   如果有，并且没有过期，直接从缓存里获取数据渲染，不再向服务器发送请求
		   如果没有，或者时间过期，重新从服务器发送请求
		   
		   强缓存bug:本地设置了缓存，如果服务器数据更新了，我们应该是去服务器拿最新的数据，
		   而不是获取缓存中的数据
		   
		   HTML页面不做强缓存，其他资源都做强缓存（HTML页面渲染的时候，获取其他的数据，其他是数据强缓存就可以了）
		   如果其他资源没有更新就直接去缓存里取
		   如果更新让其生成一个新的文件名（webpack)，导入到HTML页面里，并且缓存
		   
		   不能论是服务器，还是强缓存，获取数据，状态码都是200
		   
		   2.协商缓存（不论有没有缓存，必须向服务器发送请求）
		   强缓存失效了，设置了协商缓存，协商缓存才能生效，如果强缓存没失效，协商缓存就是一个补充
		   +HTML页面，不做强缓存，做协商缓存
		   +一般其他的资源，都是做强缓存和协商缓存 推荐
		   +也有不设置强缓存，只设置协商缓存 不推荐
		   
		   前提：强缓存失效了
		   第一访问，本地没有任何缓存，直接去服务器获取数据，如果服务器要设置“协商缓存”，则
		   会在响应头返回两个字段 （Last-Modified / ETag)
		   Etag: "5499-5ad0d9fa31b00" 资源最后一次更新产生的标识
		   Last-Modified: Mon, 17 Aug 2020 07:21:48 GMT（格林尼治）  资源最后一次更新的时间
		   
		   浏览器接收到资源信息后，渲染页面的同时，查看一下返回缓存的字段，
		   如果没有Etag Last-Modified则不会在缓存里存储
		   如果有设定了最后的更新时间，就把缓存信息（有效期和相关标识）存储，并且也会将数据（图片）
		   
		   第二次访问以及多次，首先看本地缓存，不论本地缓存有还是没有，都需需要向服务器发送请求，
		   如果有Etag Last-Modified，就请求头里，通过 If-Modified-Since、If-None-Match,
		   将这两个字段发送给服务器，服务器对比字段信息
		   +一样，就说明数据没有更新，返回304
		   +不一样，数据就更新了，返回200+新数据+（Etag Last-Modified）
		   
		   客户端根据返回状态码，做不同处理
		   +304 从缓存中获取数据渲染
		   +200 直接渲染从服务器获取的数据，存储Etag Last-Modified
		   
		对于ajax/fetch获取的数据缓存处理：基于 cookie/localStorage...等方案处理即可
		
		   一般ajax/fetch获取的数据，都是不做缓存处理的，但是总有个别数据，长期不更新需要做缓存处理
		   
		   实现方案：参考强缓存机制+本地存储（具备有效期的cookie/localStorage...）实现数据缓存
		   
		   每次访问，先看本地是否有数据，
			   没有---直接去服务器获取数据，将数据缓存到本地
			   有----从缓存中获取数据
		   		   
		第三步：DNS解析
		   DNS解析：又叫域名解析，就是去DNS服务器上，将域名对应的外网IP获取到
		   情况1:第一访问域名（没有缓存）, 一定去 本地DNS服务器 解析
		        遵循：迭代查询
				依次去DNS服务查询，都要走一遍才能获得结果 根域名服务器--》顶级域名服务器--》权威域名服务器
		   情况2:不是第一访问了（已有缓存），首先去本地缓存中找就可以了
		        遵循：递归查询
				依次去某些地方，只要找到，立刻停止
				浏览器缓存--》本地host文件--》本地DNS解析器缓存---》本地DNS服务器（按照情况1来）
				
		    每一次DNS解析时间预计在20~120毫秒
			谷歌、火狐会消耗1min
			
		第四步：TCP三次握手
	       目的：建立客户端和服务器稳定的传输通道
		   TCP:建立的是稳定可靠的通信机制，但是 "慢"
		   UDP:不需要像TCP一样进行三次握手，直接传输，传输速度快，但是不稳定（丢包）
		   
		第五步：HTTP数据传输
		   阶段一：请求阶段 Request
		      客户端向服务器发送请求，把数据传给服务器
		   阶段二：响应阶段 Response
		      服务器把信息返回给客户端
		  HTTP事物：一个完整的请求(Request)和响应(Response)
		  HTTP报文：请求和响应过程中传输的具体内容
		     起始行：请求起始行，响应起始行
			 首部（头）：请求头，响应头
			 主体：请求体，响应体
			 
			Network中可以就看到 
			
		第六步：TCP四次挥手
		    目的：断开客户端和服务器稳定的传输通道
			1.客户把信息发给服务器，会主动发起断开通道的请求，“东西给你了，这边打算断开”
			2.服务器接收到客户端发送的信息，要断开工作，还需要准备一段时间，这个时候“立即给
			  客户端发一个信息”先让客户端等待，如果不立刻回复，客户端无法准确知道，信息是否发送成功过，
			  所以这里多了一次挥手的过程，这也就是四次挥手
			3.服务器把准备好的信息给客户端，同时“东西给你啦，断开吧”
			4.客户端收到服务器的信息，给服务器反馈：“收到东西了，断开”
			
		每一次“三次握手，四次挥手”，都需要消耗大量的时间，一般情况下，保持TCP通道的长连接，
		Connection: keep-alive（请求头 响应头）
		+服务器：按照过期时间，请求数量设置
		+HTTP/1.1版本 默认Connection: keep-alive
			
		第七步：客户端渲染
		DOM TREE
		CSSOM TREE
		REDER TREE
		Layout
		分层
		Painting
	</body>
	
	URI:统一资源标识
	URL:统一资源定位符
	URN:统一资源名称
	URI=URL+URN
	
	内存存储
	虚拟内存存储：页面刷新或者关闭，存储的信息会消失
	+全局变量
	+vuex/redux 公共状态管理
	
	物理内存存储：页面刷新或者关闭，存储的信息还在
	(Application---》Storage)
	+cookie
	+localStorage
	+sessionSorage
	+浏览器本地数据库存储  IndexedDB/WebSQL
</html>
