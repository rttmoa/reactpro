国内目前最火的两大前端框架：Vue(2/3) 、 React(16/18)
  1. 共同的特点
    改变了传统的前端开发模式「传统方式：直接操作DOM」
      + 容易引发DOM的回流和重绘，消耗性能
      + 我们需要处理的逻辑和编写的代码，相对是较复杂的
      + 在当前工程化和组件化开发的大环境下，传统的开发模式，需要自己去手动实现：webpack的配置、组件的处理、SPA单页面应用下的路由模式、或者公共信息的管理 等
      + ...
    Vue/React框架，都采用“数据驱动视图渲染”的机制，让开发者放弃直接操作DOM，转而去操作数据；只要把数据改变，视图会自动进行刷新，从而实现想要的效果！！

  2. 如何使用Vue和React，从整体思想上，就要去做改变和适应
    @1 视图中但凡有需要改变的，我们都构建出对应的数据模型 Model
     + 状态 state
     + 属性 props
     + ...
    @2 基于数据去构建视图「学习视图构建的语法」
     + React：JSX语法
     + Vue：Template和JSX语法
     + 视图编译的流程：先创建虚拟DOM（virtualDOM 框架自己定义的一个对象，用来描述此及诶单的特征）-> DOM-DIFF对比 -> 渲染为真实的DOM（原生DOM对象或页面中看到的DOM节点）
    @3 以后凡是想让视图变化，都去修改数据即可，这样视图会重新编译
    @4 框架也提供了直接操作DOM的方式：ref「但是不建议这样使用」

  3. React是MVC框架、Vue是MVVM框架
    MVVM「Model、View、ViewModel」：Vue主要实现的是ViewModel层，实现了“双向驱动”
      + M->V：数据驱动视图的渲染
      + V->M：视图中信息的变化(一般指表单中内容的变化)，会自动去更改对应的数据
    MVC「Model、View、Controller」：React帮助我们提供一些特定的方法，实现“单向驱动”
      + M->V：数据驱动视图的渲染（基于react提供的方法「例如：setState、forceUpdate、一些Hook函数等」，去修改数据，会告知视图重新渲染！！）
      + V->M：React内部没有自动实现“视图驱动数据”，需要开发者手动去处理（给元素做事件绑定和监听，当内容变化时，手动去修改数据）
    
  4. Vue/React框架，除了框架本身外，都有一套完善的生态体系
    @1 脚手架（可以快速创建出基于webpack/rollup...等构建的工程化项目）
      React：create-react-app、...
      Vue：@vue/cli、...
    @2 框架本身有一套自己完善的组件化开发体系
      Vue：SFC单文件组件「视图、逻辑和数据、样式及私有化」
      React：“.jsx”组件构建的方式「视图、逻辑和数据；样式及私有化需要额外的处理；」
      ----
      组件的分类：
        + 函数组件「Hooks组件」 、类组件
        + 全局组件、局部组件
      ----
      常用的组件：
        + 普通业务组件
        + 通用业务组件：复用性高的业务组件
        + 通用功能组件：UI组件库中的，我们可能会结合业务需求进行二次封装
          Vue：ElementUI、Antd of Vue、iview、vant、cubeUI...
          React：Antd、AntdMobile...
    @3 对于SPA单页面应用的路由机制，框架也提供好了
      Vue：vue-router
      React：react-router-dom 5/6
    @4 对于公共信息的管理，框架也有现成的体系
      Vue：vuex、pinia
      React：redux（redux、react-redux、redux-thunk、redux-promise、redux-logger、redux-saga、@reduxjs/toolkit）、Mobx、Dva、Umi...
    .....
    我们把以上东西，称之为：Vue/React全家桶


=====================
使用create-react-app的时候，如果想修改脚手架生成的默认配置项，达到我们项目期望的效果
  + 首先去读源码「需要我们对webpack有一定的了解」
  + 了解其内部的处理机制后，我们就可以基于：
    + 基于 cross-env 设置环境变量修改一些需求
    + 或者直接修改源码
  ----
  + 如果觉得这样的学习成本太大了，有啥需求后，可以去网上找答案，网上会告诉你如何修改「但不一定都有」
  + 也可以基于 roadhog 修改 create-react-app 的配置「但是一样对webpack有一些基础的要求」{无需基于 $ yarn eject 暴露配置项，直接配置 .roadhogrc 去修改相关的配置即可}
  ----
  一般我们都会修改啥？
  + 配置预编译语言「默认是Sass」
  + 配置别名
  + 配置浏览器的兼容
  + 配置跨域代理
  + 配置本地启动服务器的相关信息
  + 还有一些优化项
  + ...

===================
1. JSX视图中只允许出现一个根节点
  我们可以使用 <></> 空文档标记标签，来保证唯一的根节点，而且还不增加层级结构处理
  它的原理是：<React.Fragment></React.Fragment>
2. 基于 “{}” 胡子语法，嵌入JS表达式
  + { } 大胡子  {{ }} 小胡子
  + JS表达式：执行有结果的，例如
    + 值（或者是存储值的变量）
      + 原始值类型都可以放进来，但是：true/false/null/undefined/symbol类型/bigInt类型等原始值，渲染的结果都是空，只有数字和字符串可以渲染出内容
      + 对于对象类型：
        + 数组对象是可以渲染的，它会把数组中的每一项分别进行渲染：不是转换为字符串(每一项之间是没有逗号分隔)，而是内部有一套自带的循环机制，会迭代数组每一项，进行渲染！
        + 对于函数对象，基于胡子语法渲染不可以，但是我们可以把其作为一个组件进行渲染「除了合成事件绑定」
        + 给style设置行内样式的时候，可以允许胡子语法中嵌入对象
        + 可以嵌入JSX虚拟DOM对象
        + 剩下的对象都不能嵌入
    + 数学/JS运算「函数执行也算，但是要看其返回值」
    + 判断语句：只有三元运算符是JS表达式
    + 循环语句：一般使用数组中的迭代方法（主要是map），原理就是基于数组迭代方法，返回一个新数组，React会把新数组中的每一项分别进行渲染！！
    + ...
3. 给元素设置样式
  + 设置样式类名：className
  + 设置行内样式：style={{color:'red'}} 其值必须是一个基于胡子语法嵌入的对象
4. 如果是循环创建新的元素，需要给创建的元素设置唯一的key值
  + key必须是本次循环中唯一的值
  + 建议不要用索引作为key「为什么？咱们以后讲」
5. ReactJSX语法有自己单独的事件绑定机制：合成事件绑定
  合成事件绑定的方法，经过内部一些列处理后，最后把绑定的方法单独作为普通函数执行，所以函数中的this情况，就按照这个标准来分析即可！！
    + 普通函数：this->undefined 
    + 箭头函数：上下文中的this是谁，这里就是谁
    + 可以基于原生JS中的bind方法，预先处理this和传递的实参

===================
JSX的底层渲染机制「视图的编译机制」：创建virtualDOM -> DOM-DIFF -> 真实DOM
  1. 创建virtualDOM「虚拟DOM对象/JSX对象/JSX元素对象...」
    @1 基于 babel-preset-react-app 语法包，对我们编写的JSX视图进行编译，把其编译为 React.createElement 这样的模式！！
      https://babeljs.io/repl
      React.createElement(
        标签名/组件,
        给标签或者组件设置的属性「如果没设置，则为null」,
        第三个及以后的参数，都是当前元素的子节点「可能没有」
      );
      但凡是一个HTML元素或者组件，都要编译为createElement这种格式！！

    @2 把createElement方法执行，返回一个对象 
      对象={
        $$typeof: Symbol(react.element),
        type:传递给createElement方法的第一个参数值「标签名或者组件」,
        props:{
            把传递给createElement的第二个参数中的内容，都放在这个对象中,
            如果有子节点，则设置一个children属性，属性值：
              + 可能是一个值
              + 也可能是一个数组
              + 没有子节点则children属性都不存在
        },
        ....
      }
      对象是被冻结的
      基于createElement方法创建的这个对象，就是我们所谓的：virtualDOM(JSX元素对象)
      virtualDOM其实就是框架内部对视图编译后的结果，一个框架自己构建的对象，用来描述元素的相关特征

  2. 对于视图第一次渲染来讲，直接把virtualDOM变为真实DOM
    基于ReactDOM中的render方法，把virtualDOM传递进来；render内部按照virtualDOM对象中的每一个字段，把virtualDOM变为真实的DOM对象，最后放在#root容器中渲染！！
      => render(virtualDOM)
      => 真实的DOM对象：浏览器可以识别的真实DOM对象

===========================
ReactDOM中的render在渲染virtualDOM的时候，如果发现virtualDOM中的type：
  @1 是一个字符串：则创建一个这样的标签，把props中的属性赋值给标签，并且把props.children作为子节点，基于递归的方案，依次插入到新创建的标签中！！
  @2 是一个函数组件：把函数执行「闭包那一套...」，并且把包含children的props作为实参，传递到函数中；接收函数的返回值进行渲染！！
  @3 是一个类组件：new 构造函数执行，创建类组件的一个实例，并且把包含children的props作为实参传递进去「传递到构造函数中」
     + getDefaultProps 初始化属性「含规则校验」
     + 执行constructor
     + getInitialState 初始化状态「把视图中需要的数据，放在this.state中 => 构建Model数据层」
     + 「钩子」执行componentWillMount「第一次渲染之前」
        注意：此钩子函数是不安全的，未来可能要被移除，不推荐我们使用了！如果一定要使用，前面最好设置UNSAFE（UNSAFE_componentWillMount）！但是在React.StrictMode模式下，会抛出警告错误！
     + 「钩子」执行render「组件渲染：所以我们需要把组件的视图放在render函数中返回」
     + 「钩子」执行componentDidMount「第一次渲染完毕」
        + 此时可以获取到真实的DOM元素了（？）
        + 还可以在此处异步获取服务器数据，然后让组件更新渲染真实的内容！！
        + 有些需求还需要设置定时器/监听器，再或者用一些其它的插件等
        + ...
     ------------
     如果在类组件内部，基于某些操作，让组件更新
       @1 setState 修改状态
         + 「钩子」执行shouldComponentUpdate
           返回TRUE则继续，返回FALSE则结束
           再此阶段，THIS上的属性和状态还未被更改
         + 「钩子」执行componentWillUpdate「不安全的」
         修改THIS上的属性和状态信息
         + 「钩子」执行render
         + 「钩子」执行componentDidUpdate
         + 触发setState中的callback执行
       @2 forceUpdate 强制更新
         会直接跳过shouldComponentUpdate函数，强制视图更新
         + 「钩子」执行componentWillUpdate「不安全的」
         + 「钩子」执行render
         + 「钩子」执行componentDidUpdate
         + 触发forceUpdate中的callback执行
     ------------
     如果是父组件更新，则子组件也是要更新的
       + 「钩子」执行componentWillReceiveProps「不安全的」
       + 「钩子」执行shouldComponentUpdate
       + ...
     ------------
     如果组件销毁
       + 「钩子」执行componentWillUnmount
       销毁组件

===========================
生命周期函数「俗称：钩子函数」
  在一段程序，完整流程内的某个阶段，我们可以单独做一些事情；这些函数是框架内部提供的，我们只需要在指定的函数内部做自己要做的事，框架在处理中，会帮我们把对应的函数执行！！

===========================
在当下前端开发中，组件化开发是必然的，所以我们一定要具备“抽离、分析、封装”组件的能力，而且需要让组件具备很强的“复用性”「满足更多的需求」！！
  @1 设计开发这款组件的时候，需要具备很多“不确定性”
    + 需要调用组件的时候告诉组件，这样组件内部才能基于传递的不同信息，呈现出不同的效果
    + 主要就是基于“属性和插槽”给组件传递信息
      + 如果需要传递一些数据值，则基于不同的属性传递即可；组件内部接收属性且做规则校验！！
      + 如果需要传递一些geng复杂的内容(比如DOM元素)，则基于插槽把内容传递进来！！
  所有属性和插槽是用来增强一个组件的复用性的！！

  @2 调用我们封装的组件的时候，可以给其设置ref 
    + 如果我们是基于类组件封装的，则基于ref获取的是组件的实例对象「我们封装的时候，想给父组件用啥，就暴露在实例对象上即可」！！
    + 如果我们是基于函数组件封装的，则基于 forwardRef + useImperativeHandle 把组件内部的某些信息暴露出来，供父组件调用！！

===========================
在React18中，setState修改状态且通知视图更新的操作，是“异步”“批处理”的「不论在哪里执行」！！
  + react内部自己构建了渲染队列机制「this.updater」
  + 每一次执行setstate，基于this.updater.enqueueSetState这个方法，让操作加入渲染队列中！
  + 等待“同步操作”执行完毕，会通知队列中的任务统一“批处理”！
  好处：在出现连续状态更改的逻辑下，可以让视图只更新一次，以此来优化性能，以及让代码执行的逻辑更加清晰！

如果想获取修改后的状态值，如何处理？
  + 在setState的callback函数中获取
  + 也可以在render或者componentDidUpdate钩子函数中获取
  + 当然我们也可以基于 ReactDOM 中提供的 flushSync 函数，“强制刷新”任务更新队列（this.updater）,让其立即的修改状态和视图更新！！ => flushSync可以在同步任务没有结束之前，强制让updater队列中的任务渲染一次！！

但是在React16中，setState操作即可能是同步，也可能是异步！！
  + 异步：大部分操作都是异步的「也是利用了updater渲染队列机制处理的，例如：在合成事件、钩子函数中等」
  + 同步：如果setState是在其它的异步中操作，则其本身是同步的「例如：在定时器、Promise、addEventListener等异步操作中，执行setState是同步的」